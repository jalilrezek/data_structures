# Discussion

## Unit testing TreapMap

I found difficulty from the fact that the Treap has randomness built into it. Each time it is run with a non-seeded
Random object, it is likely to exhibit different behavior. To get around this I used a Treap with a seeded Random
object in my tests. 

Even so I still had difficulties from the fact that rotations are determined based on priority values. So, when
trying to test that a particular rotation worked, I would need the priority values to be such that they allowed
that rotation to happen. If they were different, a different rotation would occur. 

Here are the priority values from Random(0): 
-1155484576
-723955400
1033096058
-1690734402
-1557280266
1327362106
-1930858313
502539523
-1728529858
-938301587
1431162155
1085665355
1654374947
-1661998771
-65105105

For instance, for my **insertOneRightRotation() test**, I wanted to test exactly one right rotation after insertion.

The tree I was generating looked like this: 

(root W, one right  child V)

                     (W)
                    /
                  (V)

I wanted it to then undergo right rotation to become: 

(root V, one left child W) 

                     (V)
                       \
                        (W)

But, based on the values generated by Random(0), I would have no rotations for the first three insertions, and then
two rotations triggered by the fourth. This is because -1155484576 < -723955400 < 1033096058. Thus, because of the
priorities continually getting higher, subsequent nodes are inserted according to the BST order without any rotations
at all. Then, once we get to the fourth value, -1690734402, since it is less than any preceding value, we undergo
multiple rotations to bring it from the bottom all the way to the top.

To get around this, I had to test other Random seed values until I found one that would cause just one rotation
before it caused multiple rotations. I settled on -2. Its values are:
1155484575
732419875
-675488479
-1086884149

The second value is less than the first, allowing for immediate rotation to occur as desired.


A third issue I faced, closely related to the first, was the need to test my code by manually tracing it out. I encountered
this in the first test I wrote, **insertCausesThreeLeftRotations()**. Online simulators were hard to find because
they didn't allow the user to set the seed value.

With the values from Random(0) above, here is the tree I generated:
                    A
                     \
                      B
                       \
                        C     // as explained above, no rotations until inserting fourth element.
                         \
                          D  // this element has the lowest priority of all four, 
                             // so it will get left-rotated thrice to the top once it is added.

Now we do three left rotations and get this: 
                   D
                 /
                A
                 \
                  B 
                   \
                    C

Removals were easier because priorities didn't matter for them. We would just sink the removed node to the bottom
and then delete it. 
This series of operations would mean that the order of the rest of the tree was preserved. I observed this
when tracing my function **insertCausesThreeLeftRotationsThenRemoveOne()** by hand. This operation would sink D down
by three successive right rotations until it was gone:
                    A
                     \
                      D
                     /
                    B
                   /
                  C
followed by:
                  A
                   \
                    B
                     \
                      D
                     /
                    C

followed by: 
                 A
                  \
                   B
                    \
                     C
                      \
                       D

whereupon we simply delete D because it is a leaf, leaving us with the complete tree that preserves the original
arrangement of the non-deleted nodes.

## Benchmarking

Texts are arranged in order of increasing size.

Hotel California: AVL < BST < Treap

Benchmark                  Mode  Cnt  Score   Error  Units
JmhRuntimeTest.arrayMap    avgt    2  0.181          ms/op
JmhRuntimeTest.avlTreeMap  avgt    2  0.123          ms/op
JmhRuntimeTest.bstMap      avgt    2  0.139          ms/op
JmhRuntimeTest.treapMap    avgt    2  0.163          ms/op


Federalist 1:  BST < AVL < Treap

Benchmark                  Mode  Cnt  Score   Error  Units
JmhRuntimeTest.arrayMap    avgt    2  1.643          ms/op
JmhRuntimeTest.avlTreeMap  avgt    2  0.677          ms/op
JmhRuntimeTest.bstMap      avgt    2  0.632          ms/op
JmhRuntimeTest.treapMap    avgt    2  0.783          ms/op


Pride and Prejudice: BST < AVL < Treap

Benchmark                  Mode  Cnt    Score   Error  Units
JmhRuntimeTest.arrayMap    avgt    2  519.774          ms/op
JmhRuntimeTest.avlTreeMap  avgt    2   55.443          ms/op
JmhRuntimeTest.bstMap      avgt    2   54.547          ms/op
JmhRuntimeTest.treapMap    avgt    2   62.714          ms/op

Moby Dick: AVL < BST < Treap

JmhRuntimeTest.arrayMap    avgt    2  2264.709          ms/op
JmhRuntimeTest.avlTreeMap  avgt    2   100.640          ms/op
JmhRuntimeTest.bstMap      avgt    2   100.737          ms/op
JmhRuntimeTest.treapMap    avgt    2   120.486          ms/op


The results surprised me a bit since I was expecting Treap to be better than the AVL tree, as it can ensure O(lg n)
search with high probability and at lower cost due to its simpler operations. However, Treap was the worst in all 
four scenarios. 

For the very small text, Hotel California, the AVL tree just barely outperformed BST. For the next two texts,
BST slightly outperformed AVL. Then, for the longest text, AVL just barely outperformed BST. In all four cases,
Treap was the slowest by a decent margin.

I think it's possible that AVL was faster on the small text (Hotel California) purely by random chance, i.e. the way
that the text is arranged, perhaps leading to some linear degeneracy in the BST such that the rotations of AVL
proved worthwhile. 

It's possible that AVL caught up to BST for the very large text (Moby Dick). This is because
we would expect AVL to outperform BST in the very long run, when the probability  of some degree of linear degeneracy 
is appreciable, and the benefit of AVL tree guaranteeing O(lg n) search outweighs the cost of its complex recursive
rebalancing operations. 

In general, however, we would expect AVL to be slower than BST. This is because it is unlikely for linear degeneracy
to occur, and in the meantime AVL spends a lot of time on its balancing rotations. The BST, by contrast, is free
from this cost.

It is possible that Treap performed the worst because its system of rotation based on the assignment of random 
priorities may have led to many, many rotations occurring. AVL tree's rotations might be more time-intensive individually,
but AVL only rotates when it needs to; by contrast, the Treap may have been rotating very frequently because its rotations
are based on the assignment of random priorities and the maintenance of the min-heap property. 

This could also explain why Treap was slower than BST. If it was slower than the computationally complex AVL tree, 
and the AVL tree was itself slower than the BST, which is the most computationally simple of all, then it would make
sense that Treap would be slower than the BST. With the low probability of linear degeneracy, the Treap could effectively
be like a BST but with the addition of many needless rotations.

ArrayMap was the slowest as expected because of its reliance on linear as opposed to logarithmic search.